[{"content":"Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems\u0026quot; by Martin Kleppmann is an exceptional resource for those of us captivated by the intricacies of data-heavy applications. It\u0026rsquo;s more than a book; it\u0026rsquo;s a voyage into the heart of contemporary data systems. Having recently immersed myself in its contents, I\u0026rsquo;m excited to share my impressions with you.\nThe book is organized into three sections: Foundations of Data Systems, Distributed Data, and Derived Data. Each section is further divided into chapters that explore the nuances of the topic at hand. From the start, his approachable prose sets a welcoming tone, making even the uninitiated feel at home. The initial chapters lay the groundwork by exploring the attributes that define applications as reliable, scalable, and maintainable. This serves as a touchstone throughout the book, reminding us of the reasons we delve into the intricate world of data systems.\nSections such as \u0026ldquo;Data Models and Query Languages\u0026rdquo; and \u0026ldquo;Storage and Retrieval\u0026rdquo; delve into the fundamental elements that mold our interactions with data. Kleppmann\u0026rsquo;s talent for balancing theoretical concepts with real-world relevance shines through. By the time we reach \u0026ldquo;Encoding and Evolution,\u0026rdquo; we\u0026rsquo;re armed with the tools to appreciate the complexities of ensuring our data models evolve seamlessly.\nThe complexity increases as we venture into the more advanced sections. \u0026ldquo;Replication\u0026rdquo; and \u0026ldquo;Partitioning\u0026rdquo; are two chapters that explore the intricacies of distributed systems. Kleppmann\u0026rsquo;s ability to distill complex concepts into digestible chunks is on full display here. The book discusses single-leader replication, multi-leader replication, and leaderless replication, among other topics. He goes onto compare the pros and cons of each approach, providing a holistic view of the tradeoffs involved. Replication is having multiple copies of the same data on different nodes. For very large datasets, this might not be enough. We need to partition the data across multiple nodes. Kleppmann\u0026rsquo;s coverage of this topic is equally comprehensive, covering everything from partitioning strategies to rebalancing techniques.\n\u0026ldquo;The Trouble with Distributed Systems\u0026rdquo; is a chapter that will resonate with anyone who\u0026rsquo;s encountered the challenges of these intricate systems. Kleppmann\u0026rsquo;s candid approach to discussing pitfalls and potential solutions makes this section particularly compelling. Terms like \u0026ldquo;Consistency and Consensus\u0026rdquo; may sound esoteric, but Kleppmann deftly transforms them into tangible concepts that elicit nods of understanding.\nThe expedition concludes with \u0026ldquo;Derived Data,\u0026rdquo; offering insights into higher-level perspectives of data systems. From data warehousing to batch and stream processing, the book paints a panoramic view of how data transforms into actionable insights. The journey culminates with \u0026ldquo;The Future of Data Systems,\u0026rdquo; a chapter that invites us to contemplate the horizon with a blend of excitement and thoughtfulness.\nThroughout the book, Kleppmann\u0026rsquo;s guidance resembles that of an experienced guide leading us through uncharted territories. His skillful fusion of theory with practical applications distinguishes this work. It\u0026rsquo;s not just about the mechanics; it\u0026rsquo;s about understanding the rationale behind them, and that\u0026rsquo;s what truly sets this book apart. As someone immersed in the world of Big Data systems and machine learning, I\u0026rsquo;ve found this book to be an indispensable companion.\nHowever, this isn\u0026rsquo;t just a theoretical manual; it\u0026rsquo;s a practical toolkit for anyone traversing the landscape of data-intensive applications. The insights contained within have already started shaping my professional approach, and I\u0026rsquo;m eager to apply Kleppmann\u0026rsquo;s wisdom to my upcoming endeavors.\nConclusion \u0026ldquo;Designing Data-Intensive Applications\u0026rdquo; can be described as a beacon of clarity in the complexity-laden expanse. Whether you\u0026rsquo;re a seasoned expert or a newcomer to the tech realm, this book offers something of value. Kleppmann\u0026rsquo;s engaging writing style, coupled with his comprehensive coverage, makes this a must-read.\nSo, to all tech enthusiasts, developers, and data devotees out there, grab yourself a copy of this book and plunge into the world of data-intensive marvels. It promises to expand your horizons and equip you with the knowledge necessary to craft systems that are not only robust, scalable, and sustainable, but also genuinely transformative. Happy reading! ðŸ“šðŸš€\n","permalink":"https://justhomas.in/posts/recommended-books/designing-data-intensive-applications-martin-kleppmann/","summary":"Dive into the comprehensive review of Martin Kleppmann\u0026rsquo;s book, \u0026ldquo;Designing Data-Intensive Applications.\u0026rdquo; Explore its coverage of foundational data systems, distributed data complexities, and derived data insights. Discover how this book bridges theory and practice, making it an essential read for both tech professionals and beginners in the field. Uncover why this book is a guiding light for creating scalable, reliable, and maintainable systems in the era of Big Data.","title":"A Comprehensive Exploration of 'Designing Data-Intensive Applications' by Martin Kleppmann"},{"content":"Introduction When it comes to working with sequences of data in Python, the itertools, iterators, and generators play a significant role in enhancing efficiency and maintaining code readability. In this blog post, we\u0026rsquo;ll delve into the intricacies of these concepts and explore how they can be utilized effectively in your Python projects.\nUnderstanding Itertools and the next() Function The itertools module is a powerhouse of utility functions that simplify common tasks involving iterators. One commonly misunderstood aspect is the usage of the next() function from the itertools module. Unlike popular belief, this function doesn\u0026rsquo;t remove elements from an iterable. Instead, it retrieves the next item from an iterator, thus advancing the iterator\u0026rsquo;s internal state for subsequent calls to next().\nimport itertools # Create an iterator iterable = [1, 2, 3, 4, 5] iterator = iter(iterable) # Get the next item next_item = next(iterator) print(next_item) # Output: 1 In scenarios where you want to reset an iterator\u0026rsquo;s position to the first element, there isn\u0026rsquo;t a built-in method within itertools to achieve this directly. However, you can either create a new iterator for the iterable or utilize the iter() function to generate a new iterator. An alternative approach involves using itertools.tee() to create multiple independent iterators from a single iterable, and then moving one of the iterators forward until it reaches the desired position.\n# Moving the iterator\u0026#39;s \u0026#34;head\u0026#34; to the first element new_iterator = iter(iterable) # Or using itertools.tee() iter1, iter2 = itertools.tee(iterable) next(iter1) # Move to the first element The Anatomy of Iterators An iterator is an object that adheres to the iterator protocol, characterized by the presence of two methods: iter() and next().\niter() Method: This method returns the iterator object itself. It\u0026rsquo;s used in contexts like for-in loops where an iterable is expected.\nnext() Method: Responsible for returning the next item from the iterator. If no more items are available, it raises a StopIteration exception. This method is pivotal in for-in loops and other scenarios involving iterables.\nA typical iterator is implemented by creating a class with iter() and next() methods. The iter() method often returns self, while the next() method utilizes an internal state variable to track the current and upcoming items.\nclass MyIterator: def __init__(self, data): self.data = data self.index = 0 def __iter__(self): return self def __next__(self): if self.index \u0026lt; len(self.data): item = self.data[self.index] self.index += 1 return item raise StopIteration # Usage my_iter = MyIterator([10, 20, 30]) for item in my_iter: print(item) The Power of Generators Generators provide an elegant and concise way to create iterators in Python. They automatically implement the iterator protocol without the need for explicitly defining iter() and next() methods. Generators can be constructed using generator functions or expressions.\nGenerator Function:\ndef countdown(n): while n \u0026gt; 0: yield n n -= 1 # Usage for num in countdown(5): print(num) Generator Expression: squared = (x ** 2 for x in range(5)) for val in squared: print(val) Conclusion Understanding the nuances of itertools, iterators, and generators in Python can significantly enhance your programming efficiency. The itertools module simplifies common iterator-related tasks, iterators adhere to the iterator protocol, and generators provide a concise way to create iterators without the need for explicit method definitions. By leveraging these concepts, you can write cleaner, more efficient, and highly readable code in your Python projects.\n","permalink":"https://justhomas.in/posts/itertools-iterator-and-generator-in-python/","summary":"Introduction When it comes to working with sequences of data in Python, the itertools, iterators, and generators play a significant role in enhancing efficiency and maintaining code readability. In this blog post, we\u0026rsquo;ll delve into the intricacies of these concepts and explore how they can be utilized effectively in your Python projects.\nUnderstanding Itertools and the next() Function The itertools module is a powerhouse of utility functions that simplify common tasks involving iterators.","title":"Demystifying Itertools, Iterators, and Generators in Python"},{"content":"Assignment Statements Do Not Copy Objects You might already know that python assignment statements do not copy objects. Instead, they create bindings between a target and an object. When you assign a variable to another variable, you are not creating a copy of the object. Instead, you are creating a new reference to the same object.\na = [1, 2, 3] b = a print(a is b) # True Now this might seem like a copy, but it\u0026rsquo;s not. It\u0026rsquo;s just two names for the same object. If you change one, you change the other.\na = [1, 2, 3] b = a a.append(4) print(b) # [1, 2, 3, 4] You might think why this could be a problem. Well, it\u0026rsquo;s not a problem if you know what you\u0026rsquo;re doing. But if you\u0026rsquo;re not careful, you might end up with unexpected results. Let\u0026rsquo;s look at an example:\nWe use dictionaries to store some of the configuration values. A class/object might be a better option to store the configs in this case. But for the sake of this example, let\u0026rsquo;s use dictionaries.\nimport matplotlib.pyplot as plt # Default plot configuration settings default_plot_config = { \u0026#39;xlabel\u0026#39;: \u0026#39;X-axis\u0026#39;, \u0026#39;ylabel\u0026#39;: \u0026#39;Y-axis\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Default Title\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;blue\u0026#39;, \u0026#39;linestyle\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;linewidth\u0026#39;: 1.0, } # Create a custom plot configuration by copying the default (shallow copy) custom_plot_config1 = default_plot_config # Modify the custom plot configuration custom_plot_config1[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 1\u0026#39; custom_plot_config1[\u0026#39;color\u0026#39;] = \u0026#39;red\u0026#39; # Create another custom plot configuration by deep copying the default custom_plot_config2 = default_plot_config # Modify the second custom plot configuration custom_plot_config2[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 2\u0026#39; custom_plot_config2[\u0026#39;linewidth\u0026#39;] = 2.0 # Sample data x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] # Create plots using custom configurations plt.figure(figsize=(8, 6)) # Set the figure size plt.subplot(2, 1, 1) plt.plot(x, y, label=\u0026#39;Data\u0026#39;, color=custom_plot_config1[\u0026#39;color\u0026#39;], linestyle=custom_plot_config1[\u0026#39;linestyle\u0026#39;], linewidth=custom_plot_config1[\u0026#39;linewidth\u0026#39;]) plt.xlabel(custom_plot_config1[\u0026#39;xlabel\u0026#39;]) plt.ylabel(custom_plot_config1[\u0026#39;ylabel\u0026#39;]) plt.title(custom_plot_config1[\u0026#39;title\u0026#39;]) plt.legend() plt.subplot(2, 1, 2) plt.plot(x, y, label=\u0026#39;Data\u0026#39;, color=custom_plot_config2[\u0026#39;color\u0026#39;], linestyle=custom_plot_config2[\u0026#39;linestyle\u0026#39;], linewidth=custom_plot_config2[\u0026#39;linewidth\u0026#39;]) plt.xlabel(custom_plot_config2[\u0026#39;xlabel\u0026#39;]) plt.ylabel(custom_plot_config2[\u0026#39;ylabel\u0026#39;]) plt.title(custom_plot_config2[\u0026#39;title\u0026#39;]) plt.legend() plt.tight_layout() # Adjust subplot spacing plt.show() The above code produces the following output:\nAs you can see, both plots have the same title, color, and line style. This is because when we assigned the default plot configuration to the custom plot configurations, we didn\u0026rsquo;t create copies. Instead, we created references to the same object. So when we modified the custom plot configurations, we modified the default plot configuration.\nShallow Copy A shallow copy creates a new object and then inserts references to the objects found in the original. In essence, a shallow copy is only one level deep. The copying process does not recurse and therefore won\u0026rsquo;t create copies of the child objects themselves. But in some cases, this might be exactly what you want. Let\u0026rsquo;s look at an example:\nimport copy # Default plot configuration settings default_plot_config = { \u0026#39;xlabel\u0026#39;: \u0026#39;X-axis\u0026#39;, \u0026#39;ylabel\u0026#39;: \u0026#39;Y-axis\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Default Title\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;blue\u0026#39;, \u0026#39;linestyle\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;linewidth\u0026#39;: 1.0, } # Create a custom plot configuration by copying the default (shallow copy) custom_plot_config1 = copy.copy(default_plot_config) # Modify the custom plot configuration custom_plot_config1[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 1\u0026#39; custom_plot_config1[\u0026#39;color\u0026#39;] = \u0026#39;red\u0026#39; Now we are creating a shallow copy of the default plot configuration. This means that the custom plot configuration will have its own copy of the default plot configuration. But the child objects will still be references to the original objects.\nDeep Copy A deep copy creates a new object and then recursively inserts copies into it of the objects found in the original. In essence everything is copied recursively, resulting in a fully independent clone of the original object and all of its children. Let\u0026rsquo;s look at an example:\nimport copy # Default plot configuration settings default_plot_config = { \u0026#39;xlabel\u0026#39;: \u0026#39;X-axis\u0026#39;, \u0026#39;ylabel\u0026#39;: \u0026#39;Y-axis\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Default Title\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;blue\u0026#39;, \u0026#39;linestyle\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;linewidth\u0026#39;: 1.0, } # Create another custom plot configuration by deep copying the default custom_plot_config2 = copy.deepcopy(default_plot_config) # Modify the second custom plot configuration custom_plot_config2[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 2\u0026#39; custom_plot_config2[\u0026#39;linewidth\u0026#39;] = 2.0 Fixing the above code. The complete code using the copy module is as follows:\nimport copy import matplotlib.pyplot as plt # Default plot configuration settings default_plot_config = { \u0026#39;xlabel\u0026#39;: \u0026#39;X-axis\u0026#39;, \u0026#39;ylabel\u0026#39;: \u0026#39;Y-axis\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Default Title\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;blue\u0026#39;, \u0026#39;linestyle\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;linewidth\u0026#39;: 1.0, } # Create a custom plot configuration by copying the default (shallow copy) custom_plot_config1 = copy.copy(default_plot_config) # Modify the custom plot configuration custom_plot_config1[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 1\u0026#39; custom_plot_config1[\u0026#39;color\u0026#39;] = \u0026#39;red\u0026#39; # Create another custom plot configuration by copying the default (shallow copy) custom_plot_config2 = copy.copy(default_plot_config) # Modify the second custom plot configuration custom_plot_config2[\u0026#39;title\u0026#39;] = \u0026#39;Custom Plot 2\u0026#39; custom_plot_config2[\u0026#39;linewidth\u0026#39;] = 2.0 # Sample data x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] # Create plots using custom configurations plt.figure(figsize=(8, 6)) # Set the figure size plt.subplot(2, 1, 1) plt.plot(x, y, label=\u0026#39;Data\u0026#39;, color=custom_plot_config1[\u0026#39;color\u0026#39;], linestyle=custom_plot_config1[\u0026#39;linestyle\u0026#39;], linewidth=custom_plot_config1[\u0026#39;linewidth\u0026#39;]) plt.xlabel(custom_plot_config1[\u0026#39;xlabel\u0026#39;]) plt.ylabel(custom_plot_config1[\u0026#39;ylabel\u0026#39;]) plt.title(custom_plot_config1[\u0026#39;title\u0026#39;]) plt.legend() plt.subplot(2, 1, 2) plt.plot(x, y, label=\u0026#39;Data\u0026#39;, color=custom_plot_config2[\u0026#39;color\u0026#39;], linestyle=custom_plot_config2[\u0026#39;linestyle\u0026#39;], linewidth=custom_plot_config2[\u0026#39;linewidth\u0026#39;]) plt.xlabel(custom_plot_config2[\u0026#39;xlabel\u0026#39;]) plt.ylabel(custom_plot_config2[\u0026#39;ylabel\u0026#39;]) plt.title(custom_plot_config2[\u0026#39;title\u0026#39;]) plt.legend() plt.tight_layout() # Adjust subplot spacing plt.show() This will produce the following output:\nAs you can see, the plots now have different titles, colors, and line styles. This is because we created a copy of the default plot configuration. So when we modified the custom plot configurations, we didn\u0026rsquo;t modify the default plot configuration.\nShallow copies of dict and list objects The python dictionary method has its own copy() method that returns a shallow copy of the dictionary.\nd = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}\rd2 = d.copy() Similarly, a list object in python can be copied by using the slice operator [:].\nl = [1, 2, 3]\rl2 = l[:] Some problems with deepcopy() As mentioned earlier, deepcopy() creates a copy of the object and all of its children. deepcopy() is only relevant for compound objects (objects that contain other objects, like lists or class instances).\nProblem 1: Recursive Object Complex objects that have references to themselves, either directly or indirectly, can result in endless recursive loops.\nProblem 2: Over-Copying with Deep Copy Deep copy, as it replicates all elements, can sometimes lead to over-copying, including data that should be shared among the copies.\nFor Example,\nimport copy default_config = {\u0026#39;theme\u0026#39;: \u0026#39;light\u0026#39;, \u0026#39;font_size\u0026#39;: 12} config1 = copy.deepcopy(default_config) config2 = copy.deepcopy(default_config) # Modify config1 config1[\u0026#39;theme\u0026#39;] = \u0026#39;dark\u0026#39; print(default_config) # {\u0026#39;theme\u0026#39;: \u0026#39;light\u0026#39;, \u0026#39;font_size\u0026#39;: 12} print(config1) # {\u0026#39;theme\u0026#39;: \u0026#39;dark\u0026#39;, \u0026#39;font_size\u0026#39;: 12} print(config2) # {\u0026#39;theme\u0026#39;: \u0026#39;light\u0026#39;, \u0026#39;font_size\u0026#39;: 12} In the above example, when we used deepcopy(), we inadvertently create copies of the entire dictionary, including the parts meant to be shared (\u0026lsquo;font_size\u0026rsquo;). Modifying one configuration (config1) doesn\u0026rsquo;t affect the others, but it consumes more memory than necessary. In such cases, a shallow copy or a custom copy mechanism might be more appropriate.\nConclusion In this article, we explored the difference between shallow copy and deep copy in Python. Also discussed some examples of how to use the copy module to create shallow and deep copies of objects in Python. Along with that, we learned about some of the potential problems with deepcopy() and how to avoid them. Hope you enjoyed reading this article. Happy coding! ðŸš€\nReferences Python Docs: copy â€” Shallow and deep copy operations ","permalink":"https://justhomas.in/posts/python-shallow-copy-and-deep-copy/","summary":"Learn the difference between shallow copy and deep copy in Python. Explore the copy module and its copy() and deepcopy() functionsand and how to use the copy module to create shallow and deep copies of objects in Python.","title":"The Art of Copying in Python: A Deep Dive into DeepCopy and Shallow Copy"},{"content":"Introduction to Iterators in Python. An iterator is an object in Python that represents a sequence of values. It is used to iterate over a container, such as a list, tuple, or dictionary. The iterator provides a way to access each item in the container one at a time, without having to know the details of how the container is implemented.\nHere\u0026rsquo;s an example of creating an iterator in Python:\n# Define a list of numbers numbers = [1, 2, 3, 4, 5] # Create an iterator from the list it = iter(numbers) # Iterate over the items in the list using the iterator print(next(it)) # Output: 1 print(next(it)) # Output: 2 An iterator object can be created using the iter() function. The iter() function takes an iterable object as an argument and returns an iterator object. The next() function is used to access the next item in the iterator. when there are no more items to return, it raises a StopIteration exception.\nImportance of iterators in Python programming. Iterators are an essential concept in Python programming and are used extensively in many aspects of the language. Here are a few reasons why iterators are important in Python:\nMemory efficiency:. Iterators are memory efficient because they don\u0026rsquo;t store the entire sequence in memory. Instead, they generate the next item in the sequence on demand. This makes them ideal for working with large sequences of data. Lazy evaluation:. Iterators are lazy because they don\u0026rsquo;t generate the next item in the sequence until it is needed. This makes them ideal for working with infinite sequences of data. Composability:. Iterators are composable because they can be chained together to create more complex sequences. This makes them ideal for working with sequences of data that are derived from other sequences. Flexibility: Iterators are a flexible way to work with data. They can be used to create custom sequences of data, or to transform or filter existing sequences. This makes them a powerful tool for many programming tasks. Basic Iterator Usage Let\u0026rsquo;s take a look at some examples of using iterators in Python.\nConverting a list to an iterator # Define a list of numbers numbers = [1, 2, 3, 4, 5] # Create an iterator from the list it = iter(numbers) # Iterate over the items in the list using the iterator print(next(it)) # Output: 1 print(next(it)) # Output: 2 Using a for loop to iterate over an iterator for item in it: print(item) Using a while loop to iterate over an iterator while True: try: item = next(it) print(item) except StopIteration: break Creating Iterators in Python Creating iterators using iter() and next() functions # Define a list of numbers numbers = [1, 2, 3, 4, 5] # Create an iterator from the list it = iter(numbers) # Iterate over the items in the list using the iterator while True: try: item = next(it) print(item) except StopIteration: break Iterating over user-defined objects using iter() and next() methods class MyIterable: def __init__(self, data): self.data = data def __iter__(self): return MyIterator(self.data) class MyIterator: def __init__(self, data): self.index = 0 self.data = data def __next__(self): if self.index \u0026gt;= len(self.data): raise StopIteration result = self.data[self.index] self.index += 1 return result # Create an instance of MyIterable my_iterable = MyIterable([1, 2, 3, 4, 5]) # Create an iterator from the iterable it = iter(my_iterable) # Iterate over the items in the iterable using the iterator while True: try: item = next(it) print(item) except StopIteration: break Iterable and Iterator Protocols In Python, the terms iterable and iterator are related concepts that are used to work with sequences of data. An iterable is any object that can be looped over using a for loop, while an iterator is an object that can be used to iterate over an iterable object.\nThe iterable protocol is a set of rules that defines what it means for an object to be iterable. Specifically, an object is iterable if it defines a method called __iter__(), which returns an iterator object. This iterator object must define a method called __next__(), which returns the next item in the sequence. If there are no more items in the sequence, the iterator must raise a StopIteration exception.\nHere is an example of implementing the iterable protocol in Python:\nclass MyIterable: def __init__(self, data): self.data = data def __iter__(self): return MyIterator(self.data) class MyIterator: def __init__(self, data): self.index = 0 self.data = data def __next__(self): if self.index \u0026gt;= len(self.data): raise StopIteration result = self.data[self.index] self.index += 1 return result In the code above, we define two classes: MyIterable and MyIterator. The MyIterable class defines a method called __iter__() that returns a new instance of the MyIterator class. The MyIterator class defines a method called __next__() that returns the next item in the sequence. If there are no more items in the sequence, it raises a StopIteration exception.\nNow we can use our MyIterable class as an iterable in a for loop:\nmy_iterable = MyIterable([1, 2, 3, 4, 5]) for item in my_iterable: print(item) This will output the numbers 1 through 5, since our MyIterable class is iterable and returns an iterator that iterates over the list of numbers.\nIterator Tools and Functions Usage of itertools module for advanced iterator manipulation import itertools # Create an iterator that returns numbers from 0 to 9 it = itertools.count() print(next(it)) # Output: 0 print(next(it)) # Output: 1 print(next(it)) # Output: 2 # Create an iterator that returns numbers from 0 to 9, but only every 3rd number it = itertools.count(step=3) print(next(it)) # Output: 0 print(next(it)) # Output: 3 print(next(it)) # Output: 6 # Create an iterator that returns numbers from 0 to 9, but only every 3rd number, starting at 5 it = itertools.count(start=5, step=3) print(next(it)) # Output: 5 print(next(it)) # Output: 8 # Create an iterator that returns the same value over and over again it = itertools.repeat(42) print(next(it)) # Output: 42 # Create an iterator that returns the same value over and over again, but only 3 times it = itertools.repeat(42, times=3) print(next(it)) # Output: 42 print(next(it)) # Output: 42 print(next(it)) # Output: 42 print(next(it)) # Output: StopIteration Creating custom iterator functions using generator functions In Python, a generator function is a special type of function that can be used to create an iterator. Generator functions are defined like normal functions, but instead of using the return keyword to return a value, they use the yield keyword.\nWhen a generator function is called, it returns a generator object, which is an iterator. This iterator can be used to iterate over a sequence of values that are generated by the generator function. Each time the yield keyword is encountered in the generator function, the value is returned and the function\u0026rsquo;s state is saved. The next time the generator\u0026rsquo;s next() method is called, the function resumes where it left off, continuing execution from the last yield statement.\nHere is an example of a simple generator function that generates a sequence of numbers:\ndef number_generator(n): for i in range(n): yield i # create a generator object my_generator = number_generator(5) # iterate over the generator for number in my_generator: print(number) Advantages of iterators over lists Memory Efficiency: Iterators are more memory-efficient than lists because they generate the next value on-the-fly when requested, rather than storing all the values in memory at once. This is particularly useful when dealing with large datasets.\nLazy Evaluation: Iterators use lazy evaluation, meaning that the computation is deferred until the value is needed. This is useful for situations where you may not need to compute all the values in the sequence, or where the computation is expensive.\nInfinite Sequences: Iterators can represent infinite sequences, while lists cannot. This allows for more expressive and powerful programming patterns, such as generating an infinite stream of random numbers or iterating over an infinite sequence of prime numbers.\nComposition: Iterators can be easily composed to create complex data processing pipelines. This allows you to build complex computations by chaining together simple iterators, without having to create intermediate lists.\nComparing memory usage of iterators vs. lists Iterators and lists have different memory usage characteristics in Python. Lists store all the values in memory, while iterators only store the current value. This means that iterators are more memory-efficient than lists, since they only store the current value in memory, rather than all the values in the sequence.\nTo illustrate the difference in memory usage, let\u0026rsquo;s consider the following example code:\nimport sys # create a list of numbers from 1 to 1000000 my_list = list(range(1, 1000001)) # create an iterator that generates the same numbers my_iterator = iter(range(1, 1000001)) # get memory usage of the list list_memory_usage = sys.getsizeof(my_list) print(f\u0026#34;List memory usage: {list_memory_usage} bytes\u0026#34;) # get memory usage of the iterator iterator_memory_usage = sys.getsizeof(my_iterator) print(f\u0026#34;Iterator memory usage: {iterator_memory_usage} bytes\u0026#34;) In this example, we create a list and an iterator that both generate the same sequence of numbers from 1 to 1000000. We then measure the memory usage of the list and the iterator using the sys.getsizeof() function. When we run this code, we get the following output:\nList memory usage: 9000112 bytes Iterator memory usage: 56 bytes As we can see, the list uses significantly more memory than the iterator (9000112 bytes vs. 56 bytes). This is because the list stores all the values in memory, while the iterator only stores the current value in memory.\nThe choice between iterators and lists depends on the specific requirements of the problem at hand. If memory usage and efficiency are important, iterators are often a better choice. However, if we need to access the data multiple times, lists may be a better option.\nConclusion We can see that iterators are a powerful tool in Python that can help us process large amounts of data efficiently. By understanding the concepts of iterables and iterators, we can create custom classes that allow us to manipulate data in a variety of ways. We\u0026rsquo;ve also learned about the performance differences between iterators and lists, and when it\u0026rsquo;s appropriate to use one over the other.\nWhew! That was a lot of information to take in, but don\u0026rsquo;t worry, iterators are a fascinating and powerful tool that will save you time and make your code more efficient. Remember to keep these concepts in mind the next time you\u0026rsquo;re working with large datasets, and you\u0026rsquo;ll be well on your way to becoming a Python master.\nSo go forth, dear reader, and iterate to your heart\u0026rsquo;s content!\nReferences Python Iterators ","permalink":"https://justhomas.in/python/iterator_in_python/","summary":"Introduction to Iterators in Python. An iterator is an object in Python that represents a sequence of values. It is used to iterate over a container, such as a list, tuple, or dictionary. The iterator provides a way to access each item in the container one at a time, without having to know the details of how the container is implemented.\nHere\u0026rsquo;s an example of creating an iterator in Python:","title":"Mastering Iterators in Python: Understanding the Iterable and Iterator Protocols"},{"content":"Introduction We all know that Django is an amazing web framework. It is very easy to use and has a lot of features. One can easily create a web application with Django. But what if you want to add some custom functionality to your application. FLet\u0026rsquo;s say you want to keep track of every request made to your app, or maybe you want to modify the request before it gets to the view or change the response before it\u0026rsquo;s sent to the client. All of these can be done with Django middleware. And the best part? There\u0026rsquo;s probably already a middleware for what you need, whether it\u0026rsquo;s for rate limiting, logging, caching, or even IP blocking.\nIn this article, we\u0026rsquo;re going to dive into the world of Django middleware and see how we can use it to add some custom functionality to our app. So, buckle up and get ready to add some extra magic to your app!\nWhat is Django middleware? Django Middleware is a way to hook into the request/response cycle of your django app and modify the request or response before it gets to the view or before it\u0026rsquo;s sent to the client. It\u0026rsquo;s a great way to add some extra functionality to your app without having to modify the core code.\nLets say you want to keep track of every request made to your app. You can do this by writing a middleware that logs every request to a file. Or maybe you want to add some custom headers to every response. We can specify the middlewares we want to use in our settings.py file. Django comes with a lot of built-in middlewares that we can use. For example, we can use the built-in middleware CommonMiddleware to add some security headers to our response.\nOnce a request is made to our app, it goes through a series of steps before it gets to the view. These steps are called the request/response cycle. In some part of this cycle, the request is passed to the middleware. The middleware can then modify the request before it gets to the view. Similarly, the response can be modified before it\u0026rsquo;s sent to the client.\nSome of the Built-in Middlewares Django comes with a lot of built-in middlewares that we can use. Some of the most commonly used middlewares are:\nCommonMiddleware: This middleware adds some security headers to the response. It also adds some other headers like X-Frame-Options and X-Content-Type-Options. It also performs URL rewriting based on the APPEND_SLASH and PREPEND_WWW settings. AuthenticationMiddleware: This middleware is used to authenticate the user. It adds the request.user attribute to the request. This attribute is used to get the currently logged in user. SessionMiddleware: Django provides full support for sessions. The sessions framework allows you to store and retrieve arbitrary data on a per-site-visitor basis. This functionality can be enabled by adding the SessionMiddleware to the MIDDLEWARE setting. This middeware is activated by default in a project created with django-admin startproject.This middleware adds a request.session attribute to the request. This attribute is used to access the session data. How to activate a middleware in Django? To activate a middleware in Django, we need to add it to the MIDDLEWARE setting in our settings.py file. The MIDDLEWARE setting is a list of middleware classes that should be activated for every request. The order of the middleware classes in the list is important. The middleware classes are executed in the order they are listed in the MIDDLEWARE setting.\n# settings.py MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] The Art of Ordering Middleware in Django: Why It Matters for Your Application When Django recives a request, it applies the middlewares top-down in the order it is mentioned in the settings.py file. Once the request is passed to a MIDDLEWARE it has two options. It can either short-circuit and return a response or it can pass the request to the next middleware.\nIf the middleware returns a response, the request/response cycle is stopped and the response is sent to the client. No other middleware is executed and the request is not passed to the view.\nIf the middleware doesn\u0026rsquo;t return a response, the request is passed to the next middleware. This process continues until the request is passed to the view. Once the view is executed, the response is passed back to the middleware in the reverse order. i.e. from bottom to top. The middleware can then modify the response before it\u0026rsquo;s sent to the client.\nThe response will only pass through the middleware that is above the middleware that returned the response. For example, consider the following order of middlewares in the settings.py file.\n# settings.py MIDDLEWARE = [ \u0026#39;middleware1\u0026#39;, \u0026#39;middleware2\u0026#39;, \u0026#39;middleware3\u0026#39;, \u0026#39;middleware4\u0026#39;, \u0026#39;middleware5\u0026#39;, ] If middleware3 short-circuits and returns a response, the response will only pass through middleware1, middleware2 and middleware3. The request is not passed to the view and the response is not passed to the middlewares below middleware3. i.e. middleware4 and middleware5.\nHow to write a middleware in Django? Now that we know what a middleware is and how it can be used, let\u0026rsquo;s see how we can write a middleware in Django. We\u0026rsquo;re going to write a middleware that logs every request made to our app. We\u0026rsquo;re going to use the logging module to log the requests. The logging module is a standard Python module that provides a flexible framework for emitting log messages from Python applications. It\u0026rsquo;s a great way to log messages to a file or to the console.\n# middleware.py import logging logger = logging.getLogger(__name__) class RequestLoggerMiddleware: def __init__(self, get_response): self.get_response = get_response def __call__(self, request): response = self.get_response(request) logger.info(f\u0026#34;Request made to {request.path}\u0026#34;) return response The __init__ method is called when the middleware is initialized. The get_response argument is a callable that is used to execute the view. The __call__ method is called when the middleware is called. The __call__ method takes the request as an argument and returns the response. The __call__ method calls the view and then logs the request to the console.\nNow that we have written our middleware, we need to add it to the MIDDLEWARE setting in our settings.py file. We also need to add the logging module to our INSTALLED_APPS setting.\n# settings.py INSTALLED_APPS = [ ... \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;logging\u0026#39;, ] MIDDLEWARE = [ ... \u0026#39;middleware.RequestLoggerMiddleware\u0026#39;, ] Now that we have added our middleware to the MIDDLEWARE setting, let\u0026rsquo;s see how it works. We\u0026rsquo;re going to make a request to our app and see if the request is logged to the console.\n# views.py from django.http import HttpResponse def index(request): return HttpResponse(\u0026#34;Hello, world. This request is logged.\u0026#34;) # urls.py from django.contrib import admin from django.urls import path from .views import index urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;\u0026#39;, index, name=\u0026#34;index\u0026#34;), ] When a user makes a request to our app, the request is passed to the middleware. The middleware then calls the view and logs the request to the console.\nSummary In this article, we learned about Django middlewares. We saw what a middleware is and how it can be used. We also learned how to write a middleware in Django, how to activate a middleware in Django. Keep in mind that the order of a middleware is important and that the request/response cycle is stopped when a middleware returns a response. Hope you enjoyed this article.\n","permalink":"https://justhomas.in/python/django/middleware-in-django/","summary":"Introduction We all know that Django is an amazing web framework. It is very easy to use and has a lot of features. One can easily create a web application with Django. But what if you want to add some custom functionality to your application. FLet\u0026rsquo;s say you want to keep track of every request made to your app, or maybe you want to modify the request before it gets to the view or change the response before it\u0026rsquo;s sent to the client.","title":"Mastering Django Middlewares: A Guide to Customizing Request and Response Objects"}]